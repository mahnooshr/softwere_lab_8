# بخش اول - پیاده سازی الگوی آداپتور
برای پیاده سازی الگوی `adapter` از نوع `Object Scope` آن استفاده می کنیم و با استفاده از واسپاری (`delegation`) قابلیت های کتابخانه ها را در کد استفاده می کنیم.

### انتخاب نوع آداپتور
دلیل استفاده از نوع `Object Scope` این بود که در روش `Class Scope` برای تغییر کتابخانه گراف، مجبور بودیم آداپتور را به گونه ای تغییر دهیم که از کلاس کتابخانه جدید ارث بری کند و این باعث می شد که آداپتور وابستگی بسیاری به کتابخانه پیدا کند ولی در روش `Object Scope` کافیست که یک ارجاع به شی کلاس کتابخانه داشته داشیم و برای تغییر کتابخانه کافیست شی جدیدی را به آداپتور پاس دهیم.

### نحوه پیاده سازی الگو
برای پیاده سازی این الگو ابتدا یک `interface` به نام `GraphAdapter` می سازیم که در آن متد هایی که کد اصلی برنامه با کمک آن با کتابخانه ارتباط می گیرد را تعریف کرده است. از جمله متد هایی که استفاده شده متد `getNeighbor(vertex)` می باشد که یک عدد به عنوان عدد راس گراف را می گیرد و در خروجی لیستی از رئوس مجاور این راس را در گراف پس می دهد. 

سپس برای کتابخانه `jung` یک پیاده سازی از `GraphAdapter`  به نام `JungGraphAdapter` انجام می دهیم که در آن از واسط کتابخانه های `jung` استفاده شده. 

در نهایت با حذف فیلد `SparseMultigraph` که نشان از وابستگی مستقیم کلاس های `BfsGraphTraverse` و `DfsGraphTraverse` به کتابخانه `jung` می باشد و اضافه کردن فیلد واسط `GraphAdapter` وابستگی پروژه را به کتابخانه حذف می کنیم.

# بخش دوم - تغییر کتابخانه
در گام دوم آزمایش، هدف اصلی جایگزینی کتابخانه‌ی `JUNG` با کتابخانه‌ی `JGraphT` بود، بدون آن‌که تغییری در منطق کلی برنامه ایجاد شود. با توجه به اینکه در گام اول با استفاده از الگوی طراحی `Adapter` وابستگی مستقیم به کتابخانه`JUNG` حذف شده بود، این امکان فراهم شد که با پیاده‌سازی یک`Adapter` جدید، بتوان از یک کتابخانه‌ی دیگر برای مدیریت گراف استفاده کرد.

### چگونگی تغییر کتابخانه
با توجه به اینکه در گام اول واسطی به نام `GraphAdapter` برای استخراج همسایگان هر رأس تعریف شده بود، در این مرحله تنها کافی بود کلاس جدیدی به نام `JGraphTGraphAdapter` پیاده‌سازی شود که همین واسط را با استفاده از ساختارهای `JGraphT` مانند`<SimpleGraph<Integer, DefaultEdge>` پشتیبانی کند؛ در نتیجه، `JungGraphAdapter`  را با `JGraphTGraphAdapter` در کلاس `Main.java` جایگزین کردیم.

###  تغییرات ناشی از تغییر کتابخانه از `JUNG` به `JGraphT`
تغییر کتابخانه از `JUNG` به`JGraphT` باعث ایجاد تغییراتی در ساختار کد شد که شامل موارد زیر می‌باشد:

#### 1. تعویض کلاس ساخت گراف
کلاس ساختار گراف از `<SparseMultigraph<Integer, String` در`JUNG` به `<SimpleGraph<Integer, DefaultEdge`در`JGraphT` تغییر یافت. این کلاس در`JGraphT` امکان ایجاد گراف ساده بدون یال‌های تکراری را فراهم می‌کند.

#### 2. نحوه‌ی افزودن یال‌ها
برخلاف`JUNG` که در آن برای هر یال باید یک شناسه رشته‌ای (مانند `"E2"`) مشخص می‌شد، در`JGraphT` افزودن یال تنها با مشخص کردن دو رأس انجام می‌شود، بدون نیاز به شناسه‌ی مجزا. به عنوان مثال:

```
graph.addEdge(1, 2);
```

#### 3. نحوه‌ی استخراج همسایگان
در `JUNG`، متد `getNeighbors(vertex)` مستقیماً لیستی از همسایگان را بازمی‌گرداند.  
اما در `JGraphT` چنین متدی وجود ندارد. در نتیجه، در کلاس `JGraphTGraphAdapter` ابتدا با استفاده از متد `edgesOf(vertex)` لیست یال‌های متصل به رأس دریافت می‌شود، سپس با بررسی متدهای `()getEdgeSource` و `()getEdgeTarget`، رأس مقابل شناسایی شده و به عنوان همسایه به مجموعه افزوده می‌شود.
