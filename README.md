# بخش اول - پیاده سازی الگوی آداپتور
برای پیاده سازی الگوی `adapter` از نوع `Object Scope` آن استفاده می کنیم و با استفاده از واسپاری (`delegation`) قابلیت های کتابخانه ها را در کد استفاده می کنیم.

### انتخاب نوع آداپتور
دلیل استفاده از نوع `Object Scope` این بود که در روش `Class Scope` برای تغییر کتابخانه گراف، مجبور بودیم آداپتور را به گونه ای تغییر دهیم که از کلاس کتابخانه جدید ارث بری کند و این باعث می شد که آداپتور وابستگی بسیاری به کتابخانه پیدا کند ولی در روش `Object Scope` کافیست که یک ارجاع به شی کلاس کتابخانه داشته داشیم و برای تغییر کتابخانه کافیست شی جدیدی را به آداپتور پاس دهیم.

### نحوه پیاده سازی الگو
برای پیاده سازی این الگو ابتدا یک `interface` به نام `GraphAdapter` می سازیم که در آن متد هایی که کد اصلی برنامه با کمک آن با کتابخانه ارتباط می گیرد را تعریف کرده است. از جمله متد هایی که استفاده شده متد `getNeighbor(vertex)` می باشد که یک عدد به عنوان عدد راس گراف را می گیرد و در خروجی لیستی از رئوس مجاور این راس را در گراف پس می دهد. 

سپس برای کتابخانه `jung` یک پیاده سازی از `GraphAdapter`  به نام `JungGraphAdapter` انجام می دهیم که در آن از واسط کتابخانه های `jung` استفاده شده. 

در نهایت با حذف فیلد `SparseMultigraph` که نشان از وابستگی مستقیم کلاس های `BfsGraphTraverse` و `DfsGraphTraverse` به کتابخانه `jung` می باشد و اضافه کردن فیلد واسط `GraphAdapter` وابستگی پروژه را به کتابخانه حذف می کنیم.

# بخش دوم - تغییر کتابخانه
در گام دوم آزمایش، هدف اصلی جایگزینی کتابخانه‌ی `JUNG` با کتابخانه‌ی `JGraphT` بود، بدون آن‌که تغییری در منطق کلی برنامه ایجاد شود. با توجه به اینکه در گام اول با استفاده از الگوی طراحی `Adapter` وابستگی مستقیم به کتابخانه`JUNG` حذف شده بود، این امکان فراهم شد که با پیاده‌سازی یک`Adapter` جدید، بتوان از یک کتابخانه‌ی دیگر برای مدیریت گراف استفاده کرد.

### چگونگی تغییر کتابخانه
با توجه به اینکه در گام اول واسطی به نام `GraphAdapter` برای استخراج همسایگان هر رأس تعریف شده بود، در این مرحله تنها کافی بود کلاس جدیدی به نام `JGraphTGraphAdapter` پیاده‌سازی شود که همین واسط را با استفاده از ساختارهای `JGraphT` مانند`<SimpleGraph<Integer, DefaultEdge>` پشتیبانی کند؛ در نتیجه، `JungGraphAdapter`  را با `JGraphTGraphAdapter` در کلاس `Main.java` جایگزین کردیم.

###  تغییرات ناشی از تغییر کتابخانه از `JUNG` به `JGraphT`
تغییر کتابخانه از `JUNG` به`JGraphT` باعث ایجاد تغییراتی در ساختار کد شد که شامل موارد زیر می‌باشد:

#### 1. تعویض کلاس ساخت گراف
کلاس ساختار گراف از `<SparseMultigraph<Integer, String` در`JUNG` به `<SimpleGraph<Integer, DefaultEdge`در`JGraphT` تغییر یافت. این کلاس در`JGraphT` امکان ایجاد گراف ساده بدون یال‌های تکراری را فراهم می‌کند.

#### 2. نحوه‌ی افزودن یال‌ها
برخلاف`JUNG` که در آن برای هر یال باید یک شناسه رشته‌ای (مانند `"E2"`) مشخص می‌شد، در`JGraphT` افزودن یال تنها با مشخص کردن دو رأس انجام می‌شود، بدون نیاز به شناسه‌ی مجزا. به عنوان مثال:

```
graph.addEdge(1, 2);
```

#### 3. نحوه‌ی استخراج همسایگان
در `JUNG`، متد `getNeighbors(vertex)` مستقیماً لیستی از همسایگان را بازمی‌گرداند.  
اما در `JGraphT` چنین متدی وجود ندارد. در نتیجه، در کلاس `JGraphTGraphAdapter` ابتدا با استفاده از متد `edgesOf(vertex)` لیست یال‌های متصل به رأس دریافت می‌شود، سپس با بررسی متدهای `()getEdgeSource` و `()getEdgeTarget`، رأس مقابل شناسایی شده و به عنوان همسایه به مجموعه افزوده می‌شود.

در نهایت به‌دلیل پیاده‌سازی مناسب و کامل واسط `GraphAdapter`، کلاس‌های مربوط به پیمایش گراف (`DFS` و `BFS`) بدون نیاز به تغییر باقی ماندند و تنها آداپتور مورد استفاده در آن‌ها تعویض شد.



# بخش سوم - پاسخ به پرسش ها

## استفاده از این الگو به چه علتی قابل قبول است؟

الگوی 
Strategy
 به ما امکان می‌دهد الگوریتم‌های مختلف پیمایش مانند
  BFS، DFS
   یا الگوریتم‌های پیشرفته‌تر را به راحتی تعویض کنیم. این الگو با کپسوله کردن هر الگوریتم در کلاس مخصوص به خود، خوانایی و نگهداری کد را بهبود می دهد. 
 از آن جایی که در روش های مختلفی برای پیمایش گراف هست، این الگوریتم قابل قبول است.
همچنان این الگو وابستگی را کم می کند و از 
 اصل
  Open/Closed
  پشتیبانی می‌کند که باعث انعطاف‌پذیری بیشتر سیستم می‌شود می شود و 
   امکان اضافه کردن الگوریتم‌های جدید بدون تغییر کد موجود فراهم می‌شود. 
در نهایت، این الگو تست‌ پذیری سیستم را افزایش می‌ دهد زیرا هر استراتژی را می‌توان به صورت مستقل آزمایش کرد.


## روش تحقق این الگو را به صورت مختصر و در حد سه سطر توضح دهید.
روش تحقق این الگو به این صورت است که کلاس های 
DfsGraphTraverser, BfsGraphTraverser
می آیند و کلاس
Traverser
را پیاده سازی می کنند.
این کلاس یک متد دارد که گراف را می پیماید و هر کدام از فرزندان با توجه به الگوریتم خود این متد را پیاده سازی می کنند. 
حال برای آن که از کدام
Strategy 
برای پیمایش گراف استفاده شود، می تواند در زمان اجرا مشخص شود و با توجه به 
نیازمندی تعیین شود که کدام منطق پیمایش گراف اجرا شود، چرا که هر دو منطق موجود از 
یک ساختار استفاده میکنند.